# GASバイブコーディング基盤（最新版ログ×最新版成功コード×Gemini）設計ドキュメント

---

## 0. 目的と前提

**目的**

* 非エンジニアでも扱いやすい、シンプルで強固なデバッグ基盤を提供する。
* 「いま」の状態に集中：

  * **ログ** … 実行のたびにスプレッドシートへ **最新のみ** を保存（毎回リセット）
  * **コード** … 実行が **成功したときのみ** Googleドキュメントへ **上書き保存（常に1件）**
  * **Gemini（ジェム）** … 上記シート（ログ）とドキュメント（コード）をナレッジに登録し、会話で解析・提案

**割り切り**

* 失敗時の履歴は持たない（ノイズ排除）。
* 成功状態は常に1件のみ（Gitの代替としての最低限の「戻れる足場」）。
* シンプルさと自動化を最優先（ユーザーは意識しない運用）。

---

## 1. 全体アーキテクチャ

```
[ユーザー] ──実行──> [GASプロジェクト]
                      ├─(毎回)→ [ログ: スプレッドシート(最新のみ)]
                      └─(成功時)→ [コード: Googleドキュメント(最新のみ)]
                                      ↑
                          [Gemini ジェム]（ナレッジとして両方参照）
```

* **GAS**：`try/catch` ラッパーが全実行の入口。

  * 実行開始時：ログシートを初期化
  * 実行中：ロガーで行ごとに追記
  * 正常終了時：プロジェクトの全ソースを収集→ヘッダー付きでドキュメントへ上書き保存
* **Gemini**：ドキュメント（成功コード）＋スプレッドシート（最新ログ）を常時参照。

---

## 2. リソース構成と命名規約

* **スプレッドシート（ログ専用）**

  * ファイル名例：`GAS_LOG_latest`
  * シート名：`LOG` のみ
  * 常に最新実行のログ行だけが存在（実行開始時にクリア）
* **Googleドキュメント（成功コード専用）**

  * ファイル名例：`GAS_CODE_success_latest`
  * 成功時のみプロジェクト全ファイルを **1つの本文** に連結して上書き
  * ファイル区切りヘッダー形式（例）：`==== main.gs ====`

> 推奨：各ファイル名は Apps Script 上の表示名と一致させる（例：`main.gs`、`util.gs` など）。

---

## 3. スプレッドシートのスキーマ（LOG）

| 項目        | 型      | 例                           | 説明                         |
| --------- | ------ | --------------------------- | -------------------------- |
| timestamp | ISO文字列 | 2025-09-17T12:34:56.789Z    | `new Date().toISOString()` |
| level     | 文字列    | INFO / WARN / ERROR / DEBUG | ログレベル                      |
| function  | 文字列    | createOrder                 | 呼び出し元（任意）                  |
| step      | 文字列    | validate-inputs             | 任意の工程名                     |
| message   | 文字列    | started validation          | 要点                         |
| detail    | 文字列    | `{"payload":{"id":123}}`    | JSON文字列（必要に応じてマスク）         |
| elapsedMs | 数値     | 12                          | 前回ログからの経過ミリ秒（任意）           |

> 先頭行にヘッダーを固定。実行開始ごとにシート全削除→ヘッダー再配置。

---

## 4. 自動化フロー

1. **実行開始**

   * Script Lock 取得（多重実行の衝突回避）
   * LOG シートをクリア＆ヘッダー再配置
   * ラン開始ログ（INFO）を1行目に追加

2. **実行中**

   * 主要なステップで `Log.info()/warn()/error()/debug()` を呼び出し
   * 可能な限り **軽量な文字列**（必要なら detail に短い JSON）
   * 個人情報等は **マスク** 関数を通す

3. **成功時（例外なしで終了）**

   * Apps Script API（REST）で **プロジェクト全ソース** を取得
   * `==== filename ==== \n<source>` で連結テキスト生成
   * Googleドキュメント本文を全削除→生成テキストで **完全上書き**
   * 「成功保存完了」ログを残す（INFO）

4. **失敗時（catch）**

   * エラーメッセージとスタックを LOG に記録（ERROR）
   * **ドキュメント保存は実行しない**

5. **finally**

   * ロック解放
   * 実行サマリ（INFO）を記録

---

## 5. セキュリティと権限

**必要スコープ（manifest 例）**

```json
{
  "timeZone": "Asia/Tokyo",
  "oauthScopes": [
    "https://www.googleapis.com/auth/script.projects",
    "https://www.googleapis.com/auth/spreadsheets",
    "https://www.googleapis.com/auth/documents",
    "https://www.googleapis.com/auth/script.container.ui",
    "https://www.googleapis.com/auth/script.external_request"
  ]
}
```

* `script.projects`：Apps Script API からソース取得
* `spreadsheets` / `documents`：ログ書き込み・ドキュメント上書き
* `external_request`：REST 呼び出し（UrlFetchApp）

**API 有効化**

* Apps Script エディタ → **サービス** → **高度なGoogleサービス** → **Apps Script API** を ON
* 併せて Cloud Console 側でも **Apps Script API** を有効化

**データ保護**

* detail への生データ投入は避け、**マスク**（例：メール、電話、カード等）
* シート/ドキュメントの共有は **閲覧権限の最小化**（Gemini 連携に必要な範囲のみ）

---

## 6. 実装（GASコード例・即利用可）

> ※ 変数 `LOG_SHEET_ID` と `CODE_DOC_ID` を自身のファイル ID に置換してください。

```javascript
/***** 設定 *****************************************************/
const LOG_SHEET_ID = '<<YOUR_LOG_SPREADSHEET_ID>>';
const LOG_SHEET_NAME = 'LOG';
const CODE_DOC_ID = '<<YOUR_CODE_DOC_ID>>';
const LOG_HEADERS = ['timestamp', 'level', 'function', 'step', 'message', 'detail', 'elapsedMs'];
/****************************************************************/

function run() {
  const lock = LockService.getScriptLock();
  lock.waitLock(30 * 1000); // 最大30秒待機
  const startMs = Date.now();
  Log.start(); // LOGシート初期化＋開始ログ

  try {
    // ====== ここから業務ロジック ======
    Log.info('main', 'init', '処理を開始');
    // 例）テスト処理
    Utilities.sleep(50);
    Log.debug('main', 'query', '外部API呼び出し準備', { q: 'example' });

    // 例）疑似成功
    Utilities.sleep(100);
    Log.info('main', 'done', '処理が正常終了');

    // ====== 成功時のみ：コードをドキュメントへ上書き保存 ======
    saveProjectSourceToDoc_();

    Log.info('main', 'snapshot', '成功コードをドキュメントへ上書き保存しました');
  } catch (e) {
    Log.error('main', 'exception', maskSensitive_(String(e)), { stack: e.stack });
    // 失敗時：コード保存しない
  } finally {
    Log.info('main', 'summary', '実行完了', { totalMs: Date.now() - startMs });
    lock.releaseLock();
  }
}

/** ログユーティリティ */
const Log = (() => {
  let sheet, lastTs;

  function getSheet_() {
    if (!sheet) {
      const ss = SpreadsheetApp.openById(LOG_SHEET_ID);
      sheet = ss.getSheetByName(LOG_SHEET_NAME) || ss.insertSheet(LOG_SHEET_NAME);
    }
    return sheet;
  }

  function clearAndHeader_() {
    const s = getSheet_();
    s.clear();
    s.getRange(1, 1, 1, LOG_HEADERS.length).setValues([LOG_HEADERS]);
  }

  function append_(level, fn, step, message, detail) {
    const now = new Date();
    const nowIso = now.toISOString();
    const elapsed = lastTs ? (now.getTime() - lastTs.getTime()) : 0;
    lastTs = now;

    const row = [
      nowIso,
      level,
      fn || '',
      step || '',
      String(message || ''),
      detail ? JSON.stringify(detail).slice(0, 5000) : '',
      elapsed
    ];
    const s = getSheet_();
    s.appendRow(row);
  }

  return {
    start() {
      clearAndHeader_();
      lastTs = null;
      append_('INFO', 'system', 'start', '実行開始', null);
    },
    info(fn, step, msg, detail)  { append_('INFO',  fn, step, msg, detail); },
    warn(fn, step, msg, detail)  { append_('WARN',  fn, step, msg, detail); },
    error(fn, step, msg, detail) { append_('ERROR', fn, step, msg, detail); },
    debug(fn, step, msg, detail) { append_('DEBUG', fn, step, msg, detail); }
  };
})();

/** 成功時のみ呼び出す：プロジェクト全ソースを取得し、ドキュメント本文を全上書き */
function saveProjectSourceToDoc_() {
  const token = ScriptApp.getOAuthToken();
  const scriptId = ScriptApp.getScriptId();
  const url = `https://script.googleapis.com/v1/projects/${scriptId}/content`;

  const resp = UrlFetchApp.fetch(url, {
    method: 'get',
    headers: { Authorization: `Bearer ${token}` },
    muteHttpExceptions: true
  });

  if (resp.getResponseCode() !== 200) {
    throw new Error(`Apps Script API 呼び出し失敗: HTTP ${resp.getResponseCode()} ${resp.getContentText()}`);
  }

  const data = JSON.parse(resp.getContentText());
  const files = (data.files || []).slice().sort((a, b) => (a.name || '').localeCompare(b.name || ''));

  const chunks = [];
  files.forEach(f => {
    const name = f.name || 'unnamed';
    const source = (f.source || '') + '\n';
    chunks.push(`==== ${name} ====\n${source}`);
  });

  const fullText = chunks.join('\n');

  const doc = DocumentApp.openById(CODE_DOC_ID);
  const body = doc.getBody();

  // 既存要素を全削除（後方から）
  for (let i = body.getNumChildren() - 1; i >= 0; i--) {
    body.removeChild(body.getChild(i));
  }
  body.appendParagraph(fullText);
  doc.saveAndClose();
}

/** 簡易マスキング（必要に応じて拡張） */
function maskSensitive_(s) {
  return s
    .replace(/([a-zA-Z0-9._%+-]+)@([a-zA-Z0-9.-]+\.[a-zA-Z]{2,})/g, '***@***')
    .replace(/\b\d{10,16}\b/g, '****'); // 連続数値（電話/カード等）を雑に伏せ字
}
```

---

## 7. 運用（ユーザー体験）

* ユーザーは **`run()` を実行するだけ**。
* **毎回**：LOG シートがリセット → ログが下に積まれる
* **成功時のみ**：コードのスナップショットがドキュメントへ **完全上書き**
* 失敗時は保存なし（最新ログを見て修正→再実行）

---

## 8. Gemini（ジェム）連携

**ナレッジ登録**

* 参照元：

  * `GAS_CODE_success_latest`（Googleドキュメント）
  * `GAS_LOG_latest`（スプレッドシート）
* 権限：ジェムが両ファイルを読み取れる最小限の共有（推奨：リンク知ってる全員「閲覧」 or 組織内限定）

**推奨システムメッセージ（例）**

* 「ドキュメントは**最新成功コード**、スプレッドシートは**最新実行ログ**。ログは毎回リセットされる。失敗時はコード保存なし。」
* 「回答は：1) 原因仮説 2) 影響範囲 3) 修正案 4) 修正後の確認手順 の順で簡潔に。」

**想定プロンプト例**

* 「最新ログでエラーになっている原因は？」
* 「成功コードの関数 `createOrder` と最新ログの `step=validate-inputs` の関係を説明して」
* 「このエラーを修正するなら変更箇所を提案して。コード断片つきで。」

---

## 9. 例外・同時実行・パフォーマンス

* **同時実行**：`LockService.getScriptLock()` でクリア直後の競合を防止
* **ログ書き込み**：`appendRow` は都度 I/O（即時性重視）。超大量ログの想定がある場合は **バッファ→まとめ書き** に切替可
* **外部API失敗**：Apps Script API HTTP 200 以外は `throw` して保存を中止
* **ドキュメント上限**：通常利用では問題なし。極端な巨大コードは章分割や Drive リビジョン管理で緩和可能
* **シート上限**：毎回リセットで実質無制限

---

## 10. 運用ルール（最小）

1. 実行は **`run()` のみ** を入口にする（個別関数直実行は避ける）
2. ログは **要点＋短い detail**。長大 JSON は避ける
3. 機微情報は **必ずマスク**
4. Gemini は **ドキュメントとシート** の2つだけに限定（ナレッジのスリム化）

---

## 11. ヘッダー形式の指針

* 形式：`==== <filename> ====`
* 理由：

  * Gemini がファイル境界を把握しやすい
  * 人間にも視認性が高い
  * 後日の部分抽出・説明指示が簡単（「`==== util.gs ==== 以降を見て`」等）

---

## 12. 導入手順（チェックリスト）

* [ ] ログ用スプレッドシート作成（`LOG` シート）
* [ ] 成功コード用ドキュメント作成
* [ ] 上記 ID をスクリプト定数に設定
* [ ] 高度な Google サービス：**Apps Script API** を ON
* [ ] Cloud Console でも **Apps Script API** を有効化
* [ ] マニフェストにスコープ追記（必要なら「権限の確認」）
* [ ] `run()` をテスト実行 → シートにログが出て、成功時にドキュメントが上書きされることを確認
* [ ] Gemini ジェムに 2 ファイルをナレッジ登録（閲覧可能権限を付与）

---

## 13. テスト計画（最小）

1. **成功パス**：`run()` が正常終了 → ドキュメント上書き、ログ末尾に `summary` が出力
2. **失敗パス**：`throw new Error('x')` を挿入 → ドキュメント未更新、ログに ERROR が記録
3. **同時実行**：`run()` を短時間で2回起動 → ロックで競合しないこと
4. **マスク確認**：メール・数列が `maskSensitive_` により伏字になること

---

## 14. よくある質問（FAQ）

* **Q：失敗ログを見返したい**

  * A：本設計では保持しません。最新ログを見て原因を素早く修正し、再実行してください。履歴肥大・分析ノイズ回避のための設計です。

* **Q：過去の成功状態に戻りたい**

  * A：常に最新1件のみを保持します。運用上のシンプルさを優先しています（Git 代替の最小足場）。どうしても必要なら Drive の版管理や単発バックアップを手動運用で。

* **Q：ログが多くて重い**

  * A：ログ粒度を下げる（DEBUG 減らす）、detail を短縮、必要ならバッファリング書き込みに。

* **Q：Gemini が古い情報を参照する**

  * A：ログは毎回リセット、コードは成功時に上書き。ジェム側でナレッジの更新タイミングを確認し、キャッシュがある場合は「最新に更新して」と促す運用に。

---

## 15. 将来拡張（任意・本設計には含めない）

* **成功スナップショットの「ワンボタン手動バックアップ」**（別ドキュメント複製）
* **差分ハイライトの自動生成**（成功コード vs 現行コード）
* **ログの重要行抽出（集約ビュー）**
* **マスク強化**（正規表現辞書の充実、独自パターン学習）

---

## 16. まとめ（設計原則）

* **シンプル最優先**：ユーザーは `run()` を押すだけ
* **最新主義**：ログは最新、コードは成功最新版のみ
* **自動化**：成功時保存は完全自動、失敗時は保存しない
* **ナレッジ最適**：Gemini は常にスリムで鮮度高い情報を参照

この構成により、非エンジニアでも **「失敗を恐れずに試せる」** バイブコーディング環境を実現し、デバッグ効率を飛躍的に向上させます。
